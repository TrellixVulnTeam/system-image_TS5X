Description: Backport of fix for LP: #1284217.  This adds an additional
  UpdateAvailableStatus signal when a second CheckForUpdate is called while an
  auto-download is in progress, but only if we have cached status available.
Origin: http://bazaar.launchpad.net/~ubuntu-system-image/ubuntu-system-image/client/revision/240?start_revid=240
Bug: http://pad.lv/1284217
Forwarded: not-needed

=== modified file 'systemimage/dbus.py'
--- systemimage/dbus.py	2014-02-18 22:31:55 +0000
+++ systemimage/dbus.py	2014-02-25 16:34:04 +0000
@@ -131,7 +131,20 @@
         # Check-and-acquire the lock.
         log.info('test and acquire checking lock')
         if not self._checking.acquire(blocking=False):
-            # Check is already in progress, so there's nothing more to do.
+            # Check is already in progress, so there's nothing more to do.  If
+            # there's status available (i.e. we are in the auto-downloading
+            # phase of the last CFU), then send the status.
+            if self._update is not None:
+                self.UpdateAvailableStatus(
+                    self._update.is_available,
+                    self._downloading,
+                    self._update.version,
+                    self._update.size,
+                    self._update.last_update_date,
+                    # XXX 2013-08-22 - the u/i cannot currently currently
+                    # handle the array of dictionaries data type.  LP:
+                    # #1215586 self._update.descriptions,
+                    "")
             log.info('checking lock not acquired')
             return
         log.info('checking lock acquired')

=== modified file 'systemimage/tests/test_dbus.py'
--- systemimage/tests/test_dbus.py	2014-02-18 20:02:59 +0000
+++ systemimage/tests/test_dbus.py	2014-02-25 16:24:34 +0000
@@ -23,13 +23,13 @@
     'TestDBusGetSet',
     'TestDBusInfo',
     'TestDBusInfoNoDetails',
-    'TestDBusLP1277589',
     'TestDBusMockFailApply',
     'TestDBusMockFailPause',
     'TestDBusMockFailResume',
     'TestDBusMockNoUpdate',
     'TestDBusMockUpdateAutoSuccess',
     'TestDBusMockUpdateManualSuccess',
+    'TestDBusMultipleChecksInFlight',
     'TestDBusPauseResume',
     'TestDBusProgress',
     'TestDBusRegressions',
@@ -133,6 +133,7 @@
         self.schedule(self.iface.CheckForUpdate)
 
     def _do_UpdateAvailableStatus(self, signal, path, *args, **kws):
+        # We'll keep doing this until we get the UpdateDownloaded signal.
         self.uas_signals.append(args)
         self.schedule(self.iface.CheckForUpdate)
 
@@ -1563,7 +1564,7 @@
 """)
 
 
-class TestDBusLP1277589(_LiveTesting):
+class TestDBusMultipleChecksInFlight(_LiveTesting):
     def test_multiple_check_for_updates(self):
         # Log analysis of LP: #1277589 appears to show the following scenario,
         # reproduced in this test case:
@@ -1588,18 +1589,23 @@
         # signal, we'll immediately issue *another* CheckForUpdate, which
         # should run while the auto-download is working.
         #
-        # At the end, we should not get another UpdateAvailableStatus signal,
-        # but we should get the UpdateDownloaded signal.
+        # As per LP: #1284217, we will get a second UpdateAvailableStatus
+        # signal, since the status is available even while the original
+        # request is being downloaded.
         reactor = DoubleCheckingReactor(self.iface)
         reactor.run()
-        self.assertEqual(len(reactor.uas_signals), 1)
-        (is_available, downloading, available_version, update_size,
-         last_update_date,
-         #descriptions,
-         error_reason) = reactor.uas_signals[0]
-        self.assertTrue(is_available)
-        self.assertTrue(downloading)
-        self.assertEqual(available_version, '1600')
-        self.assertEqual(update_size, 314572800)
-        self.assertEqual(last_update_date, 'Unknown')
-        self.assertEqual(error_reason, '')
+        # We need to have received at least 2 signals, but due to timing
+        # issues it could possibly be more.
+        self.assertGreater(len(reactor.uas_signals), 1)
+        # All received signals should have the same information.
+        for signal in reactor.uas_signals:
+            (is_available, downloading, available_version, update_size,
+             last_update_date,
+             #descriptions,
+             error_reason) = signal
+            self.assertTrue(is_available)
+            self.assertTrue(downloading)
+            self.assertEqual(available_version, '1600')
+            self.assertEqual(update_size, 314572800)
+            self.assertEqual(last_update_date, 'Unknown')
+            self.assertEqual(error_reason, '')

